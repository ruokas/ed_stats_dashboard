<!DOCTYPE html>
<html lang="lt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Prognozƒós ‚Äì R≈†L SMPS</title>
  <meta name="description" content="Prognozi≈≥ skydelis R≈†L Skubiosios pagalbos skyriui.">
  <style>
    :root {
      --color-bg: #f4f7fb;
      --color-surface: #ffffff;
      --color-surface-alt: #f0f4ff;
      --color-border: rgba(37, 99, 235, 0.08);
      --color-text: #0f172a;
      --color-text-muted: #475569;
      --color-accent: #2563eb;
      --color-accent-soft: rgba(37, 99, 235, 0.15);
      --color-chart-actual: #2563eb;
      --color-chart-forecast: #f59e0b;
      --color-chart-area: rgba(245, 158, 11, 0.12);
      --shadow-elevated: 0 20px 40px -24px rgba(15, 23, 42, 0.35);
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    body[data-theme="dark"] {
      --color-bg: #050816;
      --color-surface: #0f172a;
      --color-surface-alt: #16213c;
      --color-border: rgba(148, 163, 184, 0.16);
      --color-text: #e2e8f0;
      --color-text-muted: #94a3b8;
      --color-accent: #60a5fa;
      --color-accent-soft: rgba(96, 165, 250, 0.24);
      --color-chart-actual: #60a5fa;
      --color-chart-forecast: #fbbf24;
      --color-chart-area: rgba(251, 191, 36, 0.18);
      --shadow-elevated: 0 16px 32px -18px rgba(15, 23, 42, 0.8);
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--color-bg);
      color: var(--color-text);
      display: flex;
      flex-direction: column;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    header {
      padding: clamp(16px, 3vw, 28px) clamp(20px, 5vw, 64px) 12px;
    }

    .site-links {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .site-links__group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--color-surface);
      border-radius: 999px;
      padding: 4px;
      box-shadow: var(--shadow-elevated);
    }

    .site-links__link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: 999px;
      color: var(--color-text-muted);
      font-size: 14px;
      line-height: 1.4;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .site-links__link[aria-current="page"] {
      background: var(--color-accent-soft);
      color: var(--color-accent);
      font-weight: 600;
    }

    .site-links__link:hover,
    .site-links__link:focus-visible {
      background: var(--color-accent-soft);
      color: var(--color-accent);
      outline: none;
    }

    .site-links__actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .theme-toggle {
      border: none;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 14px;
      background: var(--color-surface);
      color: var(--color-text-muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: var(--shadow-elevated);
      transition: background 0.2s ease, color 0.2s ease;
    }

    .theme-toggle:hover,
    .theme-toggle:focus-visible {
      background: var(--color-accent-soft);
      color: var(--color-accent);
      outline: none;
    }

    main {
      flex: 1 1 auto;
      padding: 0 clamp(20px, 5vw, 64px) clamp(48px, 8vw, 96px);
    }

    .page-header {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-bottom: clamp(32px, 6vw, 64px);
    }

    .page-header__eyebrow {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--color-text-muted);
    }

    .page-header__title {
      font-size: clamp(28px, 4vw, 44px);
      font-weight: 700;
      margin: 0;
    }

    .page-header__subtitle {
      margin: 0;
      color: var(--color-text-muted);
      max-width: 720px;
      font-size: 16px;
      line-height: 1.6;
    }

    .grid {
      display: grid;
      gap: clamp(16px, 3vw, 28px);
    }

    .grid--two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: start;
    }

    .card {
      background: var(--color-surface);
      border-radius: 20px;
      padding: clamp(18px, 3vw, 28px);
      box-shadow: var(--shadow-elevated);
      border: 1px solid var(--color-border);
    }

    .card--accent {
      border: 1px dashed var(--color-accent);
    }

    .card__title {
      margin: 0 0 8px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card__title svg {
      width: 20px;
      height: 20px;
      flex: 0 0 auto;
    }

    .card__subtitle {
      margin: 0 0 16px;
      font-size: 14px;
      color: var(--color-text-muted);
    }

    .card__note {
      margin-top: 12px;
      font-size: 13px;
      color: var(--color-text-muted);
    }

    .chip-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border-radius: 999px;
      padding: 6px 14px;
      background: var(--color-surface-alt);
      color: var(--color-text-muted);
      font-size: 13px;
    }

    .chip--accent {
      background: var(--color-accent-soft);
      color: var(--color-accent);
      font-weight: 600;
    }

    .forecast-controls {
      display: grid;
      gap: 16px;
      margin-top: 16px;
    }

    .forecast-controls__group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .radio-group {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 8px;
      background: var(--color-surface-alt);
      padding: 4px;
      border-radius: 999px;
    }

    .radio-pill {
      appearance: none;
      border: none;
      background: transparent;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 14px;
      color: var(--color-text-muted);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .radio-pill:checked {
      background: var(--color-accent-soft);
      color: var(--color-accent);
      font-weight: 600;
    }

    .radio-pill:focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: 2px;
    }

    .slider {
      width: 100%;
    }

    .slider-value {
      font-weight: 600;
      color: var(--color-accent);
    }

    .chart-card {
      padding: clamp(18px, 3vw, 28px);
    }

    .chart-container {
      width: 100%;
      aspect-ratio: 3 / 1.6;
      min-height: 260px;
      background: var(--color-surface-alt);
      border-radius: 16px;
      padding: 12px;
    }

    .chart-container svg {
      width: 100%;
      height: 100%;
      border-radius: 12px;
      display: block;
      background: var(--color-surface);
    }

    .legend {
      display: inline-flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-top: 16px;
      font-size: 13px;
      color: var(--color-text-muted);
    }

    .legend__item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend__swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }

    .legend__swatch--area {
      background: linear-gradient(135deg, var(--color-chart-area), transparent);
    }

    .legend__swatch--line-actual {
      background: var(--color-chart-actual);
    }

    .legend__swatch--line-forecast {
      background: var(--color-chart-forecast);
    }

    .legend__swatch--dashed {
      border-top: 2px dashed var(--color-chart-forecast);
      width: 18px;
      height: 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
    }

    .table-wrapper {
      overflow-x: auto;
    }

    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid var(--color-border);
      font-size: 14px;
    }

    tbody tr:hover,
    tbody tr:focus-within {
      background: var(--color-surface-alt);
    }

    .metric-highlight {
      font-size: clamp(28px, 4vw, 36px);
      font-weight: 700;
      margin: 0;
    }

    .metric-note {
      color: var(--color-text-muted);
      font-size: 14px;
      margin: 0;
    }

    .insight-list {
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 8px;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      background: var(--color-surface-alt);
      color: var(--color-text-muted);
    }

    .risk-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 12px;
    }

    .risk-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      border-radius: 14px;
      background: var(--color-surface-alt);
    }

    .risk-item__label {
      display: grid;
      gap: 4px;
      font-size: 14px;
    }

    .risk-level {
      font-weight: 600;
      font-size: 14px;
      padding: 4px 10px;
      border-radius: 999px;
    }

    .risk-level[data-level="≈æemas"] {
      background: rgba(34, 197, 94, 0.2);
      color: #166534;
    }

    .risk-level[data-level="vidutinis"] {
      background: rgba(250, 204, 21, 0.28);
      color: #92400e;
    }

    .risk-level[data-level="auk≈°tas"] {
      background: rgba(248, 113, 113, 0.32);
      color: #7f1d1d;
    }

    .muted {
      color: var(--color-text-muted);
      font-size: 13px;
    }

    .hidden {
      display: none !important;
    }

    .visually-hidden {
      border: 0;
      clip: rect(0 0 0 0);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px;
    }

    .progress {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: var(--color-surface-alt);
      overflow: hidden;
    }

    .progress__bar {
      height: 100%;
      background: linear-gradient(90deg, var(--color-accent) 0%, var(--color-chart-forecast) 100%);
    }

    .shortcut-hint {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--color-text-muted);
      background: var(--color-surface-alt);
      padding: 6px 10px;
      border-radius: 999px;
    }

    footer {
      margin-top: clamp(48px, 6vw, 72px);
      padding: 0 clamp(20px, 5vw, 64px) clamp(32px, 4vw, 48px);
      color: var(--color-text-muted);
      font-size: 13px;
    }

    @media (max-width: 768px) {
      header {
        padding-bottom: 0;
      }

      .chart-container {
        aspect-ratio: auto;
        min-height: 240px;
      }
    }
  </style>
</head>
<body>
  <header>
    <nav class="site-links" aria-label="Puslapiai">
      <div class="site-links__group" role="list">
        <a class="site-links__link" href="index.html" role="listitem">Ap≈ævalga</a>
        <a class="site-links__link" href="prognozes.html" role="listitem" aria-current="page">Prognozƒós</a>
      </div>
      <div class="site-links__actions">
        <span class="shortcut-hint" aria-hidden="true">Ctrl + Shift + L</span>
        <button id="themeToggleBtn" type="button" class="theme-toggle" aria-pressed="false" aria-label="Perjungti ≈°viesiƒÖ/tamsiƒÖ temƒÖ">
          <span class="theme-toggle__icon" aria-hidden="true">‚òÄÔ∏è</span>
          <span id="themeToggleLabel">≈†viesi tema</span>
        </button>
      </div>
    </nav>
  </header>
  <main>
    <header class="page-header">
      <div>
        <p class="page-header__eyebrow">Prognozi≈≥ skydelis</p>
        <h1 class="page-header__title">Prognozƒós</h1>
      </div>
      <p class="page-header__subtitle">
        Modeliuojame b≈´simas savaites ir mƒónesius remiantis R≈†L SMP skyriuje sukauptais anonimizuotais istorini≈≥ sraut≈≥ duomenimis. Skydelyje pateikiami pagrindiniai scenarijai ir greiti koregavimo ƒØrankiai.
      </p>
      <div class="chip-group" role="list">
        <span class="chip" role="listitem">Atnaujinama kas ryta 07:05</span>
        <span class="chip" role="listitem">Modelis: Gradient Boosting + sezoniniai koregavimai</span>
        <span class="chip" role="listitem">Duomen≈≥ laikotarpis: paskutiniai 24 mƒón.</span>
        <span class="chip chip--accent" role="listitem" id="lastUpdated">Paskutinƒó sinchronizacija: 2024-04-28</span>
      </div>
    </header>

    <section class="grid grid--two" aria-labelledby="forecastControlsTitle">
      <article class="card" aria-describedby="forecastControlsHelp">
        <h2 id="forecastControlsTitle" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M5 3v3" />
            <path d="M19 3v3" />
            <rect x="3" y="5" width="18" height="16" rx="2" />
            <path d="M16 9h3" />
            <path d="M5 13h6" />
            <path d="M5 17h6" />
            <path d="M13 13h3" />
          </svg>
          Horizonto pasirinkimas
        </h2>
        <p id="forecastControlsHelp" class="card__subtitle">
          Pasirinkite prognozƒós langƒÖ ir koreguokite numatomƒÖ papildomƒÖ apkrovƒÖ, kad matytumƒóte poveikƒØ.
        </p>
        <form class="forecast-controls" id="forecastForm">
          <div class="forecast-controls__group">
            <span id="horizonLegend" class="card__subtitle" aria-hidden="true">Prognozƒós tipas</span>
            <div class="radio-group" role="radiogroup" aria-labelledby="horizonLegend">
              <label>
                <input class="radio-pill" type="radio" name="horizon" value="weekly" checked>
                Artimiausios 4 savaitƒós
              </label>
              <label>
                <input class="radio-pill" type="radio" name="horizon" value="monthly">
                Artimiausi 6 mƒónesiai
              </label>
              <label>
                <input class="radio-pill" type="radio" name="horizon" value="yearly">
                Met≈≥ projekcija (12 mƒón.)
              </label>
            </div>
          </div>
          <div class="forecast-controls__group">
            <label for="loadSlider">Papildoma apkrova (%)</label>
            <input id="loadSlider" class="slider" type="range" min="-20" max="40" step="5" value="0" aria-describedby="loadSliderValue">
            <div id="loadSliderValue" class="slider-value" aria-live="polite">+0%</div>
          </div>
          <div class="forecast-controls__group">
            <label for="scenarioSelect">Scenarijaus korekcija</label>
            <select id="scenarioSelect">
              <option value="neutral">ƒÆprasta savaitƒó</option>
              <option value="seasonal">Sezoninis pikas (gripas)</option>
              <option value="event">Didelis renginys mieste</option>
              <option value="holiday">≈†ventinƒó savaitƒó</option>
            </select>
            <p id="scenarioDescription" class="card__note" aria-live="polite"></p>
          </div>
        </form>
      </article>
      <article class="card" aria-live="polite">
        <h2 class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M3 3v18h18" />
            <path d="M7 14l4-4 3 3 5-5" />
          </svg>
          Pagrindiniai rodikliai
        </h2>
        <p class="card__subtitle" id="summaryText">Prognozƒó ruo≈°iama...</p>
        <p class="metric-highlight" id="peakValue">‚Äì</p>
        <p class="metric-note" id="peakNote">Did≈æiausia dienos apkrova</p>
        <div class="progress" aria-hidden="true">
          <div class="progress__bar" id="capacityBar" style="width: 0%"></div>
        </div>
        <p class="metric-note" id="capacityNote">U≈æimtumo dalis</p>
      </article>
    </section>

    <section class="card chart-card" aria-labelledby="chartHeading">
      <h2 id="chartHeading" class="card__title">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M4 19h16" />
          <path d="M4 12l4-5 4 4 4-6 4 5" />
        </svg>
        Prognozƒós dinamika
      </h2>
      <p class="card__subtitle">Mƒólyna ‚Äì istorinis srautas, oran≈æinƒó ‚Äì modelio prognozƒó su j≈´s≈≥ korekcijomis.</p>
      <div class="chart-container" role="img" aria-describedby="chartSummary">
        <div id="chart" aria-hidden="true"></div>
      </div>
      <p id="chartSummary" class="card__subtitle">Duomenys ruo≈°iami...</p>
      <p id="forecastUpdateNote" class="card__note">Pasitikƒójimo intervalai skaiƒçiuojami pagal paskutinius 24 mƒón. duomenis.</p>
      <div class="legend" aria-hidden="true">
        <span class="legend__item"><span class="legend__swatch legend__swatch--line-actual"></span>Istoriniai duomenys</span>
        <span class="legend__item"><span class="legend__swatch legend__swatch--dashed"></span>Prognozƒó</span>
        <span id="legendConfidence" class="legend__item hidden"><span class="legend__swatch legend__swatch--area"></span>80% pasitikƒójimo juosta</span>
      </div>
    </section>

    <section class="card" aria-labelledby="tableHeading">
      <h2 id="tableHeading" class="card__title">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M3 5h18" />
          <path d="M3 10h18" />
          <path d="M3 15h18" />
          <path d="M3 20h18" />
        </svg>
        Prognozƒós detalizacija
      </h2>
      <p class="card__subtitle">Skaiƒçiai koreguojami realiu laiku pagal pasirinktƒÖ scenarij≈≥. Naudokite kaip pamain≈≥ planavimo pagrindƒÖ.</p>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th scope="col">Laikotarpis</th>
              <th scope="col">Istorinis vidurkis</th>
              <th scope="col">Modelio prognozƒó</th>
              <th scope="col">Pokytis</th>
            </tr>
          </thead>
          <tbody id="forecastTable"></tbody>
        </table>
      </div>
    </section>

    <section class="grid grid--two" aria-labelledby="bedOccupancyHeading">
      <article class="card" aria-labelledby="bedOccupancyHeading">
        <h2 id="bedOccupancyHeading" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 10h16" />
            <path d="M4 14h16" />
            <path d="M4 18h16" />
            <path d="M6 6h12l1 4H5l1-4Z" />
          </svg>
          Lov≈≥ u≈æimtumo dinamika
        </h2>
        <p class="card__subtitle">Skaiƒçiuojame pagal atvykimo ir i≈°vykimo datas ‚Äì pateikiama mƒónesinƒó lov≈≥ u≈æimtumo trajektorija.</p>
        <div class="chart-container" role="img" aria-describedby="bedSummary">
          <div id="bedChart" aria-hidden="true"></div>
        </div>
        <p id="bedSummary" class="card__subtitle">Duomenys ruo≈°iami...</p>
      </article>
      <article class="card" aria-labelledby="bedForecastHeading">
        <h2 id="bedForecastHeading" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M5 19h14" />
            <path d="m5 15 4-4 3 3 7-7" />
            <path d="M16 5h3v3" />
          </svg>
          10 met≈≥ lov≈≥ poreikio scenarijus
        </h2>
        <p class="card__subtitle">Bazinis scenarijus skaiƒçiuoja vidutinƒØ augimƒÖ i≈° istorinio lov≈≥ u≈æimtumo ir pritaiko 15% rezervo.</p>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th scope="col">Metai</th>
                <th scope="col">Prognozuojamas vid. u≈æimtumas</th>
                <th scope="col">Rekomenduojamas lov≈≥ skaiƒçius</th>
                <th scope="col">Papildomai nuo bazƒós</th>
              </tr>
            </thead>
            <tbody id="bedForecastTable">
              <tr>
                <td colspan="4">Duomenys ruo≈°iami...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p id="bedForecastNote" class="card__note">Skaiƒçiavimai ruo≈°iami...</p>
      </article>
    </section>

    <section class="grid grid--two" aria-labelledby="planningHeading">
      <h2 id="planningHeading" class="visually-hidden">Planavimo rekomendacijos</h2>
      <article class="card" aria-labelledby="shiftHeading">
        <h3 id="shiftHeading" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 4h16v6H4z" />
            <path d="M4 14h16v6H4z" />
            <path d="M8 4v16" />
          </svg>
          Pamain≈≥ planas
        </h3>
        <p class="card__subtitle">Parodo 3 did≈æiausius laikotarpius ir si≈´lomƒÖ papildom≈≥ darbuotoj≈≥ skaiƒçi≈≥ 12 val. pamainai.</p>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th scope="col">Laikotarpis</th>
                <th scope="col">Vid. pacient≈≥/d.</th>
                <th scope="col">Papildomi ≈æmonƒós</th>
              </tr>
            </thead>
            <tbody id="shiftPlanTable"></tbody>
          </table>
        </div>
        <p class="card__note">Komentaras koreguojamas pagal <code>SHIFT_PLANNING</code> reik≈°mes skripte.</p>
      </article>
      <article class="card card--accent" aria-labelledby="riskHeading">
        <h3 id="riskHeading" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="m12 9 4 8H8l4-8Z" />
            <path d="M12 3v3" />
            <path d="M12 21v-3" />
          </svg>
          Rizikos indikatoriai
        </h3>
        <p class="card__subtitle">Padeda apsisprƒôsti dƒól pasirengimo lygio ‚Äì skaiƒçiai reaguoja ƒØ pasirinktƒÖ scenarij≈≥.</p>
        <ul class="risk-list">
          <li class="risk-item">
            <div class="risk-item__label">
              <span>U≈æimtumo pikas</span>
              <span id="riskOccupancyNote" class="muted">‚Äì</span>
            </div>
            <span id="riskOccupancyLevel" class="risk-level" data-level="≈æemas">‚Äì</span>
          </li>
          <li class="risk-item">
            <div class="risk-item__label">
              <span>Augimo greitis</span>
              <span id="riskGrowthNote" class="muted">‚Äì</span>
            </div>
            <span id="riskGrowthLevel" class="risk-level" data-level="≈æemas">‚Äì</span>
          </li>
          <li class="risk-item">
            <div class="risk-item__label">
              <span>Modelio tikrumas</span>
              <span id="riskConfidenceNote" class="muted">‚Äì</span>
            </div>
            <span id="riskConfidenceLevel" class="risk-level" data-level="≈æemas">‚Äì</span>
          </li>
        </ul>
      </article>
    </section>

    <section class="grid grid--two" aria-labelledby="insightHeading">
      <article class="card" aria-labelledby="insightHeading">
        <h2 id="insightHeading" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 3v18" />
            <path d="M5 10h14" />
            <path d="m5 7 7-4 7 4" />
          </svg>
          Rekomenduojami veiksmai
        </h2>
        <ul class="insight-list">
          <li>Rezervuokite papildomƒÖ pamainƒÖ numatomam pikui (‚â• <span id="actionPeak">‚Äì</span> pacient≈≥/d.).</li>
          <li>Per≈æi≈´rƒókite registracijos resursƒÖ prie≈° <strong>piko dienƒÖ</strong> (≈ær. grafike).</li>
          <li>Aktyvuokite <em>greito ƒØvertinimo</em> komandƒÖ, jei u≈æimtumas vir≈°ija 85%.</li>
          <li>Ilgalaikiam planui atnaujinkite lov≈≥ rezervƒÖ, jei augimas per horizontƒÖ > 10%.</li>
        </ul>
      </article>
      <article class="card" aria-labelledby="shortcutHeading">
        <h2 id="shortcutHeading" class="card__title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="m12 5 7 7-7 7" />
            <path d="M5 12h14" />
          </svg>
          Greitieji veiksmai
        </h2>
        <div class="chip-group">
          <span class="chip">Ctrl + Shift + L ‚Äì tema</span>
          <span class="chip">Ctrl + K ‚Äì komand≈≥ paletƒó (planuojama)</span>
          <span class="chip">? ‚Äì pagalba (planuojama)</span>
        </div>
        <p class="card__subtitle">≈†iuos ≈°auktinius galite pritaikyti savo komandai ‚Äì ≈ær. komentarus kode.</p>
      </article>
    </section>
  </main>
  <footer>
    <p>Naudojami tik sintetiniai, anonimizuoti duomenys. Prognozƒós skirtos planavimui ir turi b≈´ti vertinamos kartu su budinƒçio gydytojo sprendimu.</p>
  </footer>
  <script>
    const TEXT = {
      weeklySummary: (peakDay, peakValue, change) => `4 savaiƒçi≈≥ langas. Pikas ${peakDay} ‚Äì apie ${peakValue} pacient≈≥ (${change >= 0 ? '+' : ''}${change} % vs istorija).`,
      monthlySummary: (peakMonth, peakValue, change) => `6 mƒónesi≈≥ langas. Pikas ${peakMonth} ‚Äì apie ${peakValue} pacient≈≥ (${change >= 0 ? '+' : ''}${change} % vs istorija).`,
      yearlySummary: (peakMonth, peakValue, change) => `12 mƒónesi≈≥ langas. Did≈æiausias mƒónuo ${peakMonth}, prognozuojama ${peakValue} pacient≈≥ (${change >= 0 ? '+' : ''}${change}% nuo bazƒós).`,
      loading: 'Prognozƒó ruo≈°iama...'
    };

    // Norƒódami prijungti real≈≥ duomen≈≥ ≈°altinƒØ, pakeiskite ≈æemiau esanƒçius masyvus
    // CSV ar API nuskaitymu ir u≈æpildykite tokia paƒçia strukt≈´ra.
    const FORECAST_DATA = {
      weekly: {
        labels: ['1 sav.', '2 sav.', '3 sav.', '4 sav.'],
        actual: [312, 328, 301, 336],
        forecast: [342, 355, 361, 372],
        confidence: {
          low: [330, 341, 348, 356],
          high: [356, 369, 378, 393]
        },
        peaks: [{ label: '3 sav. penktadienis', value: 98 }],
        baseChange: 7,
        cadenceDays: 7,
        updateNote: 'Trumpalaikƒó projekcija: remiasi paskutini≈≥ 8 savaiƒçi≈≥ duomenimis.',
        historicalWindow: 'Pastarosios 8 savaitƒós'
      },
      monthly: {
        labels: ['Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rgp'],
        actual: [1310, 1286, 1352, 1298, 1334, 1301],
        forecast: [1388, 1426, 1463, 1524, 1558, 1492],
        confidence: {
          low: [1310, 1354, 1392, 1450, 1486, 1426],
          high: [1466, 1498, 1534, 1598, 1630, 1558]
        },
        peaks: [{ label: 'Bir≈æelis', value: 512 }],
        baseChange: 6,
        cadenceDays: 30,
        updateNote: 'Vidutinio laikotarpio prognozƒó: 24 mƒón. istorija + sezoni≈°kumas.',
        historicalWindow: 'Pastarieji 24 mƒón.'
      },
      yearly: {
        labels: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rgp', 'Rgs', 'Spa', 'Lap', 'Grd'],
        actual: [1280, 1204, 1310, 1298, 1356, 1332, 1388, 1401, 1297, 1265, 1210, 1198],
        forecast: [1324, 1292, 1386, 1412, 1480, 1524, 1586, 1604, 1510, 1478, 1422, 1398],
        confidence: {
          low: [1220, 1180, 1276, 1298, 1370, 1415, 1464, 1482, 1396, 1362, 1309, 1288],
          high: [1428, 1406, 1496, 1526, 1590, 1638, 1708, 1726, 1624, 1590, 1536, 1508]
        },
        peaks: [{ label: 'Liepa', value: 612 }],
        baseChange: 8,
        cadenceDays: 30,
        updateNote: 'Metinƒó projekcija: 36 mƒón. istorija, ƒØskaitant pandemijos korekcijas.',
        historicalWindow: 'Pastarieji 36 mƒón.'
      }
    };

    // Sintetiniai istoriniai lov≈≥ u≈æimtumo duomenys ‚Äì pakeiskite realiais atvykim≈≥/i≈°vykim≈≥ mƒónesiniais skaiƒçiais.
    const BED_FLOW_DATA = [
      { date: '2021-01-01', arrivals: 860, discharges: 847 },
      { date: '2021-02-01', arrivals: 883, discharges: 869 },
      { date: '2021-03-01', arrivals: 901, discharges: 886 },
      { date: '2021-04-01', arrivals: 909, discharges: 894 },
      { date: '2021-05-01', arrivals: 907, discharges: 892 },
      { date: '2021-06-01', arrivals: 895, discharges: 880 },
      { date: '2021-07-01', arrivals: 878, discharges: 863 },
      { date: '2021-08-01', arrivals: 861, discharges: 846 },
      { date: '2021-09-01', arrivals: 849, discharges: 834 },
      { date: '2021-10-01', arrivals: 847, discharges: 832 },
      { date: '2021-11-01', arrivals: 855, discharges: 840 },
      { date: '2021-12-01', arrivals: 873, discharges: 859 },
      { date: '2022-01-01', arrivals: 896, discharges: 883 },
      { date: '2022-02-01', arrivals: 919, discharges: 905 },
      { date: '2022-03-01', arrivals: 937, discharges: 922 },
      { date: '2022-04-01', arrivals: 945, discharges: 930 },
      { date: '2022-05-01', arrivals: 943, discharges: 928 },
      { date: '2022-06-01', arrivals: 931, discharges: 916 },
      { date: '2022-07-01', arrivals: 914, discharges: 899 },
      { date: '2022-08-01', arrivals: 897, discharges: 882 },
      { date: '2022-09-01', arrivals: 885, discharges: 870 },
      { date: '2022-10-01', arrivals: 883, discharges: 868 },
      { date: '2022-11-01', arrivals: 891, discharges: 876 },
      { date: '2022-12-01', arrivals: 909, discharges: 895 },
      { date: '2023-01-01', arrivals: 932, discharges: 919 },
      { date: '2023-02-01', arrivals: 955, discharges: 941 },
      { date: '2023-03-01', arrivals: 973, discharges: 958 },
      { date: '2023-04-01', arrivals: 981, discharges: 966 },
      { date: '2023-05-01', arrivals: 979, discharges: 964 },
      { date: '2023-06-01', arrivals: 967, discharges: 952 },
      { date: '2023-07-01', arrivals: 950, discharges: 935 },
      { date: '2023-08-01', arrivals: 933, discharges: 918 },
      { date: '2023-09-01', arrivals: 921, discharges: 906 },
      { date: '2023-10-01', arrivals: 919, discharges: 904 },
      { date: '2023-11-01', arrivals: 927, discharges: 912 },
      { date: '2023-12-01', arrivals: 945, discharges: 931 }
    ];

    const BED_MODEL = {
      capacity: 126,
      initialOccupancy: 92,
      bufferPercent: 0.15
    };

    const SCENARIOS = {
      neutral: {
        label: 'ƒÆprasta savaitƒó',
        multiplier: 0,
        description: 'Modelis remiasi vien istoriniais duomenimis be papildom≈≥ korekcij≈≥.'
      },
      seasonal: {
        label: 'Sezoninis pikas (gripas)',
        multiplier: 0.12,
        description: 'Padidina apkrovƒÖ ~12% ‚Äì naudokite rudens/≈æiemos periodu arba gripo bangos metu.'
      },
      event: {
        label: 'Didelis renginys mieste',
        multiplier: 0.2,
        description: 'Didelis ≈æmoni≈≥ srautas mieste gali kilstelƒóti atvykimus ~20%. Tikrinkite su savivaldybƒós kalendoriumi.'
      },
      holiday: {
        label: '≈†ventinƒó savaitƒó',
        multiplier: -0.1,
        description: 'Atostog≈≥ periodais stebime ~10% ma≈æesnƒØ srautƒÖ, bet daugiau traumos atvej≈≥ naktimis.'
      }
    };

    const elements = {
      themeToggleBtn: document.getElementById('themeToggleBtn'),
      themeToggleLabel: document.getElementById('themeToggleLabel'),
      chartContainer: document.getElementById('chart'),
      chartSummary: document.getElementById('chartSummary'),
      forecastUpdateNote: document.getElementById('forecastUpdateNote'),
      summaryText: document.getElementById('summaryText'),
      peakValue: document.getElementById('peakValue'),
      peakNote: document.getElementById('peakNote'),
      capacityBar: document.getElementById('capacityBar'),
      capacityNote: document.getElementById('capacityNote'),
      forecastTable: document.getElementById('forecastTable'),
      shiftPlanTable: document.getElementById('shiftPlanTable'),
      legendConfidence: document.getElementById('legendConfidence'),
      actionPeak: document.getElementById('actionPeak'),
      loadSlider: document.getElementById('loadSlider'),
      loadSliderValue: document.getElementById('loadSliderValue'),
      scenarioSelect: document.getElementById('scenarioSelect'),
      scenarioDescription: document.getElementById('scenarioDescription'),
      bedChart: document.getElementById('bedChart'),
      bedSummary: document.getElementById('bedSummary'),
      bedForecastTable: document.getElementById('bedForecastTable'),
      bedForecastNote: document.getElementById('bedForecastNote'),
      riskOccupancyLevel: document.getElementById('riskOccupancyLevel'),
      riskOccupancyNote: document.getElementById('riskOccupancyNote'),
      riskGrowthLevel: document.getElementById('riskGrowthLevel'),
      riskGrowthNote: document.getElementById('riskGrowthNote'),
      riskConfidenceLevel: document.getElementById('riskConfidenceLevel'),
      riskConfidenceNote: document.getElementById('riskConfidenceNote'),
      lastUpdated: document.getElementById('lastUpdated'),
      forecastForm: document.getElementById('forecastForm')
    };

    function applyTheme(theme) {
      document.body.dataset.theme = theme;
      localStorage.setItem('ed_theme', theme);
      const isDark = theme === 'dark';
      elements.themeToggleBtn.setAttribute('aria-pressed', String(isDark));
      elements.themeToggleBtn.dataset.theme = theme;
      elements.themeToggleLabel.textContent = isDark ? 'Tamsi tema' : '≈†viesi tema';
      elements.themeToggleBtn.querySelector('.theme-toggle__icon').textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
    }

    // Pritaikykite pamain≈≥ planavimƒÖ pagal savo skyri≈≥ ‚Äì bazinis dienos srautas ir apkrova vienam darbuotojui.
    const SHIFT_PLANNING = {
      basePatientsPerDay: 180,
      patientsPerStaffPerShift: 12,
      shiftLengthHours: 12
    };

    // Maksimali pageidaujama dienos apimtis, naudojama apkrovos juostai ir rizikos vertinimui.
    const CAPACITY_SETTINGS = {
      maxDailyPatients: 420
    };

    // Rizikos lygi≈≥ slenksƒçiai (proc.). Koreguokite, jei skyriuje priimtinas kitas jautrumas.
    const RISK_THRESHOLDS = {
      occupancy: { high: 120, medium: 95 },
      growth: { high: 12, medium: 6 },
      confidence: { high: 18, medium: 10 }
    };

    // Metaduomenys rodomi vir≈°uje ‚Äì keiskite tekstƒÖ ir laikƒÖ, kai sinchronizuojate realius duomenis.
    const MODEL_METADATA = {
      lastSync: 'Paskutinƒó sinchronizacija: 2024-04-28 07:05',
      source: 'Duomen≈≥ ≈°altinis: HIS + EMS eksportai'
    };

    function toggleTheme() {
      const current = document.body.dataset.theme === 'dark' ? 'dark' : 'light';
      const next = current === 'dark' ? 'light' : 'dark';
      applyTheme(next);
    }

    function initTheme() {
      const saved = localStorage.getItem('ed_theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      applyTheme(saved || (prefersDark ? 'dark' : 'light'));
    }

    function initMetadata() {
      if (elements.lastUpdated) {
        elements.lastUpdated.textContent = MODEL_METADATA.lastSync;
        elements.lastUpdated.setAttribute('title', MODEL_METADATA.source);
        elements.lastUpdated.setAttribute('aria-label', `${MODEL_METADATA.lastSync}. ${MODEL_METADATA.source}`);
      }
    }

    function formatNumber(value) {
      return new Intl.NumberFormat('lt-LT').format(Math.round(value));
    }

    function computeAdjustedSeries(baseSeries, adjustmentMultiplier) {
      return baseSeries.map((value, index) => {
        const trendFactor = 1 + index * 0.01;
        return value * (1 + adjustmentMultiplier) * trendFactor;
      });
    }

    function computeAdjustedConfidence(confidence, adjustmentMultiplier) {
      if (!confidence) return null;
      return {
        low: computeAdjustedSeries(confidence.low, adjustmentMultiplier * 0.8),
        high: computeAdjustedSeries(confidence.high, adjustmentMultiplier * 1.2)
      };
    }

    function computeBedOccupancySeries(flowData, model) {
      const sorted = [...flowData].sort((a, b) => new Date(a.date) - new Date(b.date));
      let occupancy = model.initialOccupancy;
      return sorted.map((entry) => {
        const date = new Date(entry.date);
        const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        const netAdmissions = entry.arrivals - entry.discharges;
        const change = netAdmissions / daysInMonth;
        occupancy = Math.max(0, Math.min(model.capacity, occupancy + change));
        return {
          date,
          iso: entry.date,
          label: date.toLocaleDateString('lt-LT', { month: 'short', year: 'numeric' }),
          occupancy,
          occupancyRate: occupancy / model.capacity
        };
      });
    }

    function aggregateAnnualOccupancy(series) {
      const accumulator = new Map();
      series.forEach((point) => {
        const year = point.date.getFullYear();
        if (!accumulator.has(year)) {
          accumulator.set(year, { year, total: 0, count: 0, max: 0 });
        }
        const bucket = accumulator.get(year);
        bucket.total += point.occupancy;
        bucket.count += 1;
        bucket.max = Math.max(bucket.max, point.occupancy);
      });
      return Array.from(accumulator.values())
        .sort((a, b) => a.year - b.year)
        .map((item) => ({
          year: item.year,
          average: item.count ? item.total / item.count : 0,
          max: item.max
        }));
    }

    function computeAverageAnnualGrowth(annualSummary) {
      if (annualSummary.length < 2) {
        return 0.03;
      }
      const deltas = [];
      for (let index = 1; index < annualSummary.length; index += 1) {
        const prev = annualSummary[index - 1].average;
        const current = annualSummary[index].average;
        if (prev > 0) {
          deltas.push((current - prev) / prev);
        }
      }
      if (!deltas.length) {
        return 0.03;
      }
      const average = deltas.reduce((sum, value) => sum + value, 0) / deltas.length;
      return Math.max(-0.05, Math.min(average, 0.12));
    }

    function buildBedForecast(annualSummary, model, yearsAhead, growthRate) {
      if (!annualSummary.length) {
        return [];
      }
      const results = [];
      let projected = annualSummary[annualSummary.length - 1].average;
      const baseYear = annualSummary[annualSummary.length - 1].year;
      for (let step = 1; step <= yearsAhead; step += 1) {
        projected = projected * (1 + growthRate);
        const recommended = Math.ceil(projected * (1 + model.bufferPercent));
        results.push({
          year: baseYear + step,
          projectedAverage: projected,
          recommendedBeds: Math.max(recommended, Math.ceil(projected)),
          extraBeds: Math.max(0, recommended - model.capacity),
          peakEstimate: projected * 1.12
        });
      }
      return results;
    }

    function renderBedChart(historySeries, forecast, model) {
      if (!elements.bedChart) return;
      if (!historySeries.length) {
        elements.bedChart.innerHTML = '<p>Tr≈´ksta duomen≈≥ grafiko brai≈æymui.</p>';
        return;
      }

      const forecastPoints = forecast.map((entry) => ({
        label: `${entry.year}`,
        value: entry.projectedAverage,
        recommended: entry.recommendedBeds,
        date: new Date(entry.year, 0, 1)
      }));

      const combined = [...historySeries, ...forecastPoints];
      const width = 880;
      const height = 320;
      const padding = { top: 28, right: 32, bottom: 56, left: 60 };
      const values = combined.map((point) => point.occupancy ?? point.value);
      const scaleValues = [...values, model.capacity * (1 + model.bufferPercent)];
      const maxValue = Math.max(...scaleValues) * 1.08;
      const minValue = Math.min(...values) * 0.92;
      const totalPoints = combined.length;

      const scaleX = (index) => {
        const usableWidth = width - padding.left - padding.right;
        const step = totalPoints > 1 ? usableWidth / (totalPoints - 1) : usableWidth;
        return padding.left + index * step;
      };

      const valueRange = (maxValue - minValue) || 1;

      const scaleY = (value) => {
        const usableHeight = height - padding.top - padding.bottom;
        return height - padding.bottom - ((value - minValue) / valueRange) * usableHeight;
      };

      const historyPath = historySeries
        .map((point, index) => `${index === 0 ? 'M' : 'L'}${scaleX(index)} ${scaleY(point.occupancy)}`)
        .join(' ');

      let forecastPath = '';
      if (forecastPoints.length) {
        const startX = scaleX(historySeries.length - 1);
        const startY = scaleY(historySeries[historySeries.length - 1].occupancy);
        forecastPath = `M${startX} ${startY}`;
        forecastPoints.forEach((point, idx) => {
          const x = scaleX(historySeries.length + idx);
          const y = scaleY(point.value);
          forecastPath += ` L${x} ${y}`;
        });
      }

      let bufferPath = '';
      if (forecastPoints.length) {
        const bufferPoints = forecastPoints.map((point, idx) => ({
          x: scaleX(historySeries.length + idx),
          low: scaleY(point.value),
          high: scaleY(point.value * (1 + model.bufferPercent))
        }));
        bufferPath = `M${bufferPoints[0].x} ${bufferPoints[0].high}`;
        for (let i = 1; i < bufferPoints.length; i += 1) {
          bufferPath += ` L${bufferPoints[i].x} ${bufferPoints[i].high}`;
        }
        for (let i = bufferPoints.length - 1; i >= 0; i -= 1) {
          bufferPath += ` L${bufferPoints[i].x} ${bufferPoints[i].low}`;
        }
        bufferPath += ' Z';
      }

      const axisLines = combined.map((point, index) => {
        const x = scaleX(index);
        const isHistorical = index < historySeries.length;
        const labelText = isHistorical
          ? (point.date.getMonth() === 0 || point.date.getMonth() === 6
              ? point.date.toLocaleDateString('lt-LT', {
                  month: 'short',
                  year: point.date.getMonth() === 0 ? 'numeric' : undefined
                })
              : '')
          : point.date.getFullYear();
        const opacity = labelText ? 0.35 : 0.12;
        return `
          <line x1="${x}" y1="${height - padding.bottom}" x2="${x}" y2="${padding.top}" stroke="var(--color-border)" stroke-dasharray="4 12" opacity="${opacity}" />
          ${labelText ? `<text x="${x}" y="${height - padding.bottom + 24}" text-anchor="middle">${labelText}</text>` : ''}
        `;
      }).join('');

      const capacityLine = `<line x1="${padding.left}" y1="${scaleY(model.capacity)}" x2="${width - padding.right}" y2="${scaleY(model.capacity)}" stroke="var(--color-accent-soft)" stroke-dasharray="6 6" />`;

      elements.bedChart.innerHTML = `
        <svg viewBox="0 0 ${width} ${height}" role="presentation">
          <defs>
            <linearGradient id="bedBuffer" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stop-color="var(--color-chart-area)" stop-opacity="0.9" />
              <stop offset="100%" stop-color="var(--color-chart-area)" stop-opacity="0.1" />
            </linearGradient>
          </defs>
          <rect x="${padding.left}" y="${padding.top}" width="${width - padding.left - padding.right}" height="${height - padding.top - padding.bottom}" rx="18" fill="var(--color-surface)" />
          ${axisLines}
          ${capacityLine}
          ${bufferPath ? `<path d="${bufferPath}" fill="url(#bedBuffer)" opacity="0.6"></path>` : ''}
          <path d="${historyPath}" fill="none" stroke="var(--color-chart-actual)" stroke-width="3" />
          ${forecastPath ? `<path d="${forecastPath}" fill="none" stroke="var(--color-chart-forecast)" stroke-width="3" stroke-dasharray="8 6" />` : ''}
        </svg>
      `;
    }

    function updateBedSummary(annualSummary, forecast, model, growthRate) {
      if (!elements.bedSummary) return;
      if (!annualSummary.length) {
        elements.bedSummary.textContent = 'Tr≈´ksta istorini≈≥ lov≈≥ u≈æimtumo duomen≈≥.';
        return;
      }
      const lastYear = annualSummary[annualSummary.length - 1];
      const finalForecast = forecast[forecast.length - 1];
      const growthPercent = Math.round(growthRate * 1000) / 10;
      const occupancyPercent = Math.round((lastYear.average / model.capacity) * 100);
      const finalYearText = finalForecast ? `${finalForecast.year} m.` : `${lastYear.year} m.`;
      const finalBeds = finalForecast ? formatNumber(finalForecast.recommendedBeds) : formatNumber(Math.ceil(lastYear.average * (1 + model.bufferPercent)));
      elements.bedSummary.textContent = `${lastYear.year} m. vidutinis lov≈≥ u≈æimtumas ${formatNumber(Math.round(lastYear.average))} (${occupancyPercent}% i≈° ${model.capacity}). Prognozuojamas ${growthPercent >= 0 ? '+' : ''}${growthPercent}% metinis augimas ‚Äì ${finalYearText} reikƒót≈≥ apie ${finalBeds} lov≈≥.`;
    }

    function updateBedForecastTable(forecast) {
      if (!elements.bedForecastTable) return;
      if (!forecast.length) {
        elements.bedForecastTable.innerHTML = '<tr><td colspan="4">Tr≈´ksta prognozƒós rezultat≈≥.</td></tr>';
        return;
      }
      elements.bedForecastTable.innerHTML = forecast.map((entry) => `
        <tr>
          <th scope="row">${entry.year}</th>
          <td>${formatNumber(Math.round(entry.projectedAverage))}</td>
          <td>${formatNumber(entry.recommendedBeds)}</td>
          <td>${formatNumber(entry.extraBeds)}</td>
        </tr>
      `).join('');
    }

    function updateBedForecastNote(annualSummary, growthRate, model) {
      if (!elements.bedForecastNote) return;
      if (!annualSummary.length) {
        elements.bedForecastNote.textContent = 'Istorini≈≥ lov≈≥ duomen≈≥ nerasta ‚Äì ƒØkelkite HIS eksportƒÖ.';
        return;
      }
      const firstYear = annualSummary[0].year;
      const lastYear = annualSummary[annualSummary.length - 1].year;
      const growthPercent = Math.round(growthRate * 1000) / 10;
      elements.bedForecastNote.textContent = `Analizuojamas laikotarpis ${firstYear}‚Äì${lastYear}. Vidutinis metinis augimas ${growthPercent >= 0 ? '+' : ''}${growthPercent}%. ƒÆtrauktas ${Math.round(model.bufferPercent * 100)}% rezervas staigiems pikams.`;
    }

    function updateBedPlanning() {
      const historySeries = computeBedOccupancySeries(BED_FLOW_DATA, BED_MODEL);
      const annualSummary = aggregateAnnualOccupancy(historySeries);
      const growthRate = computeAverageAnnualGrowth(annualSummary);
      const forecast = buildBedForecast(annualSummary, BED_MODEL, 10, growthRate);
      renderBedChart(historySeries, forecast, BED_MODEL);
      updateBedSummary(annualSummary, forecast, BED_MODEL, growthRate);
      updateBedForecastTable(forecast);
      updateBedForecastNote(annualSummary, growthRate, BED_MODEL);
    }

    function buildChart({ labels, actual, forecast, confidence }) {
      const width = 880;
      const height = 340;
      const padding = { top: 32, right: 32, bottom: 48, left: 56 };
      const values = [...actual, ...forecast, ...(confidence ? [...confidence.low, ...confidence.high] : [])];
      const maxValue = Math.max(...values) * 1.12;
      const minValue = Math.min(...values) * 0.9;
      const totalPoints = labels.length;

      const scaleX = (index) => {
        const usableWidth = width - padding.left - padding.right;
        const step = totalPoints > 1 ? usableWidth / (totalPoints - 1) : usableWidth;
        return padding.left + index * step;
      };

      const scaleY = (value) => {
        const usableHeight = height - padding.top - padding.bottom;
        return height - padding.bottom - ((value - minValue) / (maxValue - minValue)) * usableHeight;
      };

      const buildPath = (series) => series.map((value, index) => `${index === 0 ? 'M' : 'L'}${scaleX(index)} ${scaleY(value)}`).join(' ');

      const axisLines = labels.map((label, index) => {
        const x = scaleX(index);
        return `
          <line x1="${x}" y1="${height - padding.bottom}" x2="${x}" y2="${padding.top}" stroke="var(--color-border)" stroke-dasharray="4 12" />
          <text x="${x}" y="${height - padding.bottom + 24}" text-anchor="middle">${label}</text>
        `;
      }).join('');

      const actualPath = buildPath(actual);
      const forecastPath = buildPath(forecast);
      const forecastAreaPath = forecast.map((value, index) => `${index === 0 ? `M${scaleX(index)} ${scaleY(value)}` : `L${scaleX(index)} ${scaleY(value)}`}`).join(' ')
        + `L${scaleX(forecast.length - 1)} ${height - padding.bottom}`
        + `L${scaleX(0)} ${height - padding.bottom}Z`;

      let confidencePath = '';
      if (confidence) {
        const upper = confidence.high.map((value, index) => `${index === 0 ? `M${scaleX(index)} ${scaleY(value)}` : `L${scaleX(index)} ${scaleY(value)}`}`).join(' ');
        const lower = confidence.low.slice().reverse().map((value, reverseIndex) => {
          const index = confidence.low.length - 1 - reverseIndex;
          return `L${scaleX(index)} ${scaleY(value)}`;
        }).join(' ');
        confidencePath = `${upper}${lower}Z`;
      }

      elements.chartContainer.innerHTML = `
        <svg viewBox="0 0 ${width} ${height}" role="presentation">
          <defs>
            <linearGradient id="forecastArea" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stop-color="var(--color-chart-area)" stop-opacity="1" />
              <stop offset="100%" stop-color="var(--color-chart-area)" stop-opacity="0" />
            </linearGradient>
          </defs>
          <rect x="${padding.left}" y="${padding.top}" width="${width - padding.left - padding.right}" height="${height - padding.top - padding.bottom}" rx="18" fill="var(--color-surface)" />
          ${axisLines}
          ${confidence ? `<path d="${confidencePath}" fill="url(#forecastArea)" opacity="0.6"></path>` : `<path d="${forecastAreaPath}" fill="url(#forecastArea)" opacity="0.9"></path>`}
          <path d="${actualPath}" fill="none" stroke="var(--color-chart-actual)" stroke-width="2.5" stroke-linejoin="round" stroke-linecap="round"></path>
          <path d="${forecastPath}" fill="none" stroke="var(--color-chart-forecast)" stroke-width="2.5" stroke-dasharray="6 6" stroke-linejoin="round" stroke-linecap="round"></path>
          ${forecast.map((value, index) => {
            const x = scaleX(index);
            const y = scaleY(value);
            return `<circle cx="${x}" cy="${y}" r="5" fill="var(--color-chart-forecast)"></circle>`;
          }).join('')}
          ${actual.map((value, index) => {
            const x = scaleX(index);
            const y = scaleY(value);
            return `<circle cx="${x}" cy="${y}" r="4" fill="var(--color-chart-actual)"></circle>`;
          }).join('')}
        </svg>
      `;
    }

    function toggleLegendConfidence(isVisible) {
      if (!elements.legendConfidence) return;
      elements.legendConfidence.classList.toggle('hidden', !isVisible);
    }

    function updateTable(labels, actual, forecast) {
      elements.forecastTable.innerHTML = labels.map((label, index) => {
        const base = actual[index] ?? actual[actual.length - 1];
        const predicted = forecast[index];
        const change = ((predicted - base) / base) * 100;
        const changeFormatted = `${change >= 0 ? '+' : ''}${change.toFixed(1)}%`;
        return `<tr>
          <th scope="row">${label}</th>
          <td>${formatNumber(base)}</td>
          <td>${formatNumber(predicted)}</td>
          <td>${changeFormatted}</td>
        </tr>`;
      }).join('');
    }

    function updateSummary(horizon, dataset, forecast) {
      const { labels, actual, cadenceDays } = dataset;
      const peakIndex = forecast.reduce((bestIndex, value, index, arr) => value > arr[bestIndex] ? index : bestIndex, 0);
      const peakValue = forecast[peakIndex];
      const basePeak = actual[peakIndex] ?? actual[actual.length - 1];
      const change = Math.round(((peakValue - basePeak) / basePeak) * 100);
      const label = labels[peakIndex];
      const summary = horizon === 'weekly'
        ? TEXT.weeklySummary(label, formatNumber(peakValue), change)
        : horizon === 'monthly'
          ? TEXT.monthlySummary(label, formatNumber(peakValue), change)
          : TEXT.yearlySummary(label, formatNumber(peakValue), change);
      const dailyPeak = cadenceDays ? peakValue / cadenceDays : peakValue;
      const occupancyPercentage = (dailyPeak / CAPACITY_SETTINGS.maxDailyPatients) * 100;

      elements.summaryText.textContent = summary;
      elements.peakValue.textContent = formatNumber(peakValue);
      elements.peakNote.textContent = `Did≈æiausia apkrova: ${label} (~${formatNumber(Math.round(dailyPeak))} pacient≈≥/d.)`;
      elements.capacityBar.style.width = `${Math.min(100, Math.max(0, occupancyPercentage))}%`;
      elements.capacityNote.textContent = dailyPeak > CAPACITY_SETTINGS.maxDailyPatients
        ? `Vir≈°ija planuotƒÖ ${CAPACITY_SETTINGS.maxDailyPatients} pacient≈≥ per dienƒÖ ribƒÖ`
        : `≈Ωemiau ${CAPACITY_SETTINGS.maxDailyPatients} pacient≈≥ per dienƒÖ ribos`;
      elements.actionPeak.textContent = formatNumber(Math.round(dailyPeak));
    }

    function updateChartSummary(horizon, dataset, forecast) {
      const average = forecast.reduce((sum, value) => sum + value, 0) / forecast.length;
      const trend = forecast[forecast.length - 1] - forecast[0];
      const trendLabel = trend >= 0 ? 'augimo' : 'ma≈æƒójimo';
      const horizonLabel = horizon === 'weekly' ? '4 savaiƒçi≈≥' : horizon === 'monthly' ? '6 mƒónesi≈≥' : '12 mƒónesi≈≥';
      elements.chartSummary.textContent = `${horizonLabel} lango vidurkis ${formatNumber(average)} pacient≈≥ per periodƒÖ, ${trend >= 0 ? '+' : ''}${Math.round(trend)} pokytis per horizontƒÖ (${trendLabel} tendencija). ${dataset.historicalWindow}.`;
    }

    function determineRiskLevel(value, thresholds) {
      if (value >= thresholds.high) return 'auk≈°tas';
      if (value >= thresholds.medium) return 'vidutinis';
      return '≈æemas';
    }

    function applyRisk(levelElement, noteElement, level, note) {
      if (levelElement) {
        levelElement.dataset.level = level;
        levelElement.textContent = level.charAt(0).toUpperCase() + level.slice(1);
      }
      if (noteElement) {
        noteElement.textContent = note;
      }
    }

    function updateScenarioDetails(scenarioKey) {
      const scenario = SCENARIOS[scenarioKey];
      if (!scenario || !elements.scenarioDescription) return;
      elements.scenarioDescription.textContent = scenario.description;
    }

    function updateShiftPlan(labels, forecast, cadenceDays) {
      if (!elements.shiftPlanTable) return;
      if (!labels.length || !forecast.length) {
        elements.shiftPlanTable.innerHTML = '<tr><td colspan="3">Nƒóra duomen≈≥</td></tr>';
        return;
      }

      const periods = labels.map((label, index) => {
        const value = forecast[index];
        const dailyAverage = cadenceDays ? value / cadenceDays : value;
        const excess = dailyAverage - SHIFT_PLANNING.basePatientsPerDay;
        const extraStaff = excess > 0 ? Math.ceil(excess / SHIFT_PLANNING.patientsPerStaffPerShift) : 0;
        return {
          label,
          dailyAverage,
          extraStaff
        };
      });

      const sorted = periods.sort((a, b) => b.dailyAverage - a.dailyAverage).slice(0, Math.min(3, periods.length));
      elements.shiftPlanTable.innerHTML = sorted.map((period) => `
        <tr>
          <th scope="row">${period.label}</th>
          <td>${formatNumber(Math.round(period.dailyAverage))}</td>
          <td>${period.extraStaff}</td>
        </tr>
      `).join('');
    }

    function updateRiskIndicators({ forecast, cadenceDays, confidence }) {
      if (!forecast.length) return;
      const peakValue = Math.max(...forecast);
      const dailyPeak = cadenceDays ? peakValue / cadenceDays : peakValue;
      const occupancyPercent = Math.round((dailyPeak / SHIFT_PLANNING.basePatientsPerDay) * 100);
      const occupancyLevel = determineRiskLevel(occupancyPercent, RISK_THRESHOLDS.occupancy);
      applyRisk(
        elements.riskOccupancyLevel,
        elements.riskOccupancyNote,
        occupancyLevel,
        `${formatNumber(Math.round(dailyPeak))} pacient≈≥/d. (bazƒó ${SHIFT_PLANNING.basePatientsPerDay})`
      );

      const growthPercent = Math.round(((forecast[forecast.length - 1] - forecast[0]) / forecast[0]) * 100);
      const growthLevel = determineRiskLevel(Math.abs(growthPercent), RISK_THRESHOLDS.growth);
      applyRisk(
        elements.riskGrowthLevel,
        elements.riskGrowthNote,
        growthLevel,
        `${growthPercent >= 0 ? '+' : ''}${growthPercent}% pokytis per pasirinktƒÖ horizontƒÖ`
      );

      if (confidence && confidence.low && confidence.high) {
        const spreads = confidence.high.map((value, index) => {
          const baseline = forecast[index] || 1;
          return ((value - confidence.low[index]) / baseline) * 100;
        });
        const avgSpread = Math.round(spreads.reduce((sum, value) => sum + value, 0) / spreads.length);
        const confidenceLevel = determineRiskLevel(avgSpread, RISK_THRESHOLDS.confidence);
        applyRisk(
          elements.riskConfidenceLevel,
          elements.riskConfidenceNote,
          confidenceLevel,
          `Pasikliautinumo juosta ¬±${avgSpread}% nuo prognozƒós`
        );
      } else {
        applyRisk(
          elements.riskConfidenceLevel,
          elements.riskConfidenceNote,
          'vidutinis',
          'Intervalai nenurodyti ‚Äì naudokite atsargiai.'
        );
      }
    }

    function updateForecastNote(dataset) {
      if (!elements.forecastUpdateNote) return;
      elements.forecastUpdateNote.textContent = dataset.updateNote || 'Intervalai apskaiƒçiuoti pagal pateiktus istorinius duomenis.';
    }

    function updateForecast() {
      const formData = new FormData(elements.forecastForm);
      const horizon = formData.get('horizon');
      const loadAdjustment = Number(elements.loadSlider.value) / 100;
      const scenario = SCENARIOS[elements.scenarioSelect.value];
      const dataset = FORECAST_DATA[horizon];
      const adjustment = loadAdjustment + scenario.multiplier;
      const adjustedForecast = computeAdjustedSeries(dataset.forecast, adjustment);
      const adjustedActual = computeAdjustedSeries(dataset.actual, 0);

      const adjustedConfidence = computeAdjustedConfidence(dataset.confidence, adjustment);

      updateScenarioDetails(elements.scenarioSelect.value);
      updateTable(dataset.labels, dataset.actual, adjustedForecast);
      updateSummary(horizon, dataset, adjustedForecast);
      updateChartSummary(horizon, dataset, adjustedForecast);
      updateShiftPlan(dataset.labels, adjustedForecast, dataset.cadenceDays);
      updateRiskIndicators({ forecast: adjustedForecast, cadenceDays: dataset.cadenceDays, confidence: adjustedConfidence });
      updateForecastNote(dataset);
      buildChart({ labels: dataset.labels, actual: adjustedActual, forecast: adjustedForecast, confidence: adjustedConfidence });
      toggleLegendConfidence(Boolean(adjustedConfidence));
    }

    elements.themeToggleBtn.addEventListener('click', toggleTheme);

    window.addEventListener('keydown', (event) => {
      if (event.key.toLowerCase() === 'l' && event.ctrlKey && event.shiftKey) {
        event.preventDefault();
        toggleTheme();
      }
    });

    elements.loadSlider.addEventListener('input', () => {
      const value = Number(elements.loadSlider.value);
      elements.loadSliderValue.textContent = `${value >= 0 ? '+' : ''}${value}%`;
      updateForecast();
    });

    elements.scenarioSelect.addEventListener('change', updateForecast);
    elements.forecastForm.addEventListener('change', (event) => {
      if (event.target.name === 'horizon') {
        updateForecast();
      }
    });

    initTheme();
    initMetadata();
    updateForecast();
    updateBedPlanning();
  </script>
</body>
</html>
